
正则表达式是码农必备看家技能, 除了打基础, 还得学会如何分析一个长的表达式, 如下:

```
 rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/

```

- 或匹配进行分割
    - (?:\s*(<[\w\W]+>)[^>]
    - `#([\w-]*)`
- ^(?:\s*(<[\w\W]+>)[^>]*
    - (?:patter): 匹配pattern但不获取匹配结果,即非获取匹配
    - \s*:匹配任何空白字符,包括空格 制表符 换页符, 等价于\s{0,}
    - (pattern): 匹配pattern,并获取这一匹配
    - [\w\W]+: 匹配于'[A-Za-z0-9_]'或[^A-Za-z0-9_]' 一次或多次， 等价{1,}
    - (<[\w\W]+>):匹配<>内部的字符串
    - [^>]*: 负值匹配, 匹配出了>的任意字符或者没有字符,等价于{0,}
- `#([\w-]*)`
    - 匹配结尾以#开头, 包含字母数字下划线与-
- exec方法
    - 如果正则表达式没有分组, 那么匹配后, 返回数组或者null, 数组的第一个元素就是匹配的串
    - 匹配成功的分组, 第一个元素是找到的匹配字符串,第二个元素是匹配中的第一个分组...(反向引用)




